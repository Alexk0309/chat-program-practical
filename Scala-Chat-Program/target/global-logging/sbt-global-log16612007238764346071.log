[0m[[0m[0mdebug[0m] [0m[0m> Exec(collectAnalyses, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Processing event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / collectAnalyses[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: Signal, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0manalysis location (/Volumes/Alex's SSD/Sunway/Semester 7/NET3204 Distributed System/Practical 10/Scala-Chat-Program/target/scala-2.12/zinc/inc_compile_2.12.zip,true)[0m
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 0 s, completed 6 Dec 2022, 4:47:02 pm[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Done event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(shell, None, None)[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///Volumes/Alex%27s%20SSD/Sunway/Semester%207/NET3204%20Distributed%20System/Practical%2010/Scala-Chat-Program/src/main/scala/com/hep88/ClientApp.scala","languageId":"scala","version":1,"text":"package com.hep88\nimport akka.cluster.typed._\nimport akka.{ actor => classic }\nimport akka.actor.typed.{ActorRef, ActorSystem}\nimport akka.actor.typed.scaladsl.adapter._\nimport com.typesafe.config.ConfigFactory\nimport scalafx.application.JFXApp\nimport scalafx.application.JFXApp.PrimaryStage\nimport scalafx.scene.Scene\nimport scalafxml.core.{FXMLLoader, NoDependencyResolver}\nimport scalafx.Includes._\nimport scala.concurrent.Future\nimport scala.concurrent.duration._\n\nobject Client extends JFXApp {\n  val greeterMain: ActorSystem[ChatClient.Command] = ActorSystem(ChatClient(), \"HelloSystem\")\n  // Starting the finding of chat server actor\n  greeterMain ! ChatClient.start\n\n  val loader = new FXMLLoader(null, NoDependencyResolver)\n  loader.load(getClass.getResourceAsStream(\"view/MainWindow.fxml\"))\n  val border: scalafx.scene.layout.BorderPane = loader.getRoot[javafx.scene.layout.BorderPane]()\n  val control = loader.getController[com.hep88.view.MainWindowController#Controller]()\n  control.chatClientRef = Option(greeterMain)\n  val cssResource = getClass.getResource(\"view/DarkTheme.css\")\n  stage = new PrimaryStage() {\n    scene = new Scene() {\n      root = border\n      stylesheets = List(cssResource.toExternalForm)\n    }\n  }\n\n  stage.onCloseRequest = handle({\n    greeterMain.terminate\n  })\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///Volumes/Alex%27s%20SSD/Sunway/Semester%207/NET3204%20Distributed%20System/Practical%2010/Scala-Chat-Program/src/main/scala/com/hep88/ChatServer.scala","languageId":"scala","version":1,"text":"package com.hep88\r\nimport akka.actor.typed.ActorRef\r\nimport akka.actor.typed.ActorSystem\r\nimport akka.actor.typed.Behavior\r\nimport akka.actor.typed.scaladsl.Behaviors\r\nimport akka.actor.typed.receptionist.{Receptionist, ServiceKey}\r\nimport com.hep88.Upnp.AddPortMapping\r\nimport scalafx.collections.ObservableHashSet\r\n\r\ncase class User (name: String , ref:ActorRef[ChatClient.Command])\r\n\r\nobject ChatServer {\r\n  // Protocol\r\n  sealed trait Command\r\n  case class JoinChat(name:String, ref:ActorRef[ChatClient.Command]) extends Command\r\n  case class Leave(name: String, from: ActorRef[ChatClient.Command]) extends Command\r\n\r\n  // Service Key\r\n  val ServerKey: ServiceKey[ChatServer.Command] = ServiceKey(\"Server\")\r\n\r\n  //Server state\r\n  val members = new ObservableHashSet[User]()\r\n\r\n  members.onChange((newSet, c) => {\r\n    import com.hep88.ChatClient._\r\n    val newList = MemberList(newSet.toList)\r\n    for (user <- newSet) {\r\n      user.ref ! newList\r\n    }\r\n  })\r\n\r\n  def apply(): Behavior[ChatServer.Command] =\r\n    Behaviors.setup { context =>\r\n      val upnpRef = context.spawn(Upnp(), Upnp.name)\r\n      upnpRef ! AddPortMapping(20000)\r\n\r\n      context.system.receptionist ! Receptionist.Register(ServerKey, context.self)\r\n\r\n      Behaviors.receiveMessage { message =>\r\n        message match {\r\n          case JoinChat(name, ref) =>\r\n            import com.hep88.ChatClient._\r\n            ChatServer.members += User(name, ref)\r\n            ref ! Joined(ChatServer.members.toList)\r\n            Behaviors.same\r\n\r\n          case Leave(name, from) =>\r\n            members -= User(name, from)\r\n            Behaviors.same\r\n        }\r\n      }\r\n    }\r\n}\r\n\r\nobject ServerApp extends App { // Create server skeleton\r\n  val greeterMain: ActorSystem[ChatServer.Command] = ActorSystem(ChatServer(), \"HelloSystem\")\r\n\r\n}\r\n"}})[0m
